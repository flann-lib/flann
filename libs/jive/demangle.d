/**
	D symbol name demangling

	Attempts to demangle D symbols generated by the DMD frontend.
	(Which is not always technically possible)

   Copyright: Copyright (C) 2007-2008 Zygfryd (aka Hxal). All rights reserved.
   License:   zlib
   Authors:   Zygfryd (aka Hxal)

 */

module jive.demangle;

private import tango.stdc.stdlib : alloca;
private import tango.text.Unicode : isLetter, isLetterOrDigit;
private import tango.util.Convert : to;
private import tango.text.Util : locatePattern;

//import tango.io.Stdout;

/**
   
 */
public class Demangler
{
	debug(traceDemangler) private char[][] _trace;

	/** How deeply to recurse printing template parameters,
	  * for depths greater than this, an ellipsis is used */
	uint templateExpansionDepth = 1;

	/** Skip default members of templates (sole members named after
	  * the template) */
	bool foldDefaults = true;

	/** Print types of functions being part of the main symbol */
	bool expandFunctionTypes = false;

	/** For composite types, print the kind (class|struct|etc.) of the type */
	bool printTypeKind = false;

	/** */
	public void verbosity (uint level)
	{
		switch (level)
		{
			case 0:
				templateExpansionDepth = 0;
				expandFunctionTypes = false;
				printTypeKind = false;
				break;

			case 1:
				templateExpansionDepth = 1;
				expandFunctionTypes = false;
				printTypeKind = false;
				break;

			case 2:
				templateExpansionDepth = 1;
				expandFunctionTypes = false;
				printTypeKind = true;
				break;

			case 3:
				templateExpansionDepth = 1;
				expandFunctionTypes = true;
				printTypeKind = true;
				break;

			default:
				templateExpansionDepth = level - 2;
				expandFunctionTypes = true;
				printTypeKind = true;
		}
	}

	/** */
	this ()
	{
		verbosity (1);
	}

	/** */
	this (uint verbosityLevel)
	{
		verbosity (verbosityLevel);
	}

	private char[] input;
	private uint _templateDepth = 0;

	debug (traceDemangler)
	{
		private void trace (char[] where)
		{
			if (_trace.length > 500)
				throw new Exception ("Infinite recursion");

			char[] spaces = (cast(char*) alloca (_trace.length)) [0 .. _trace.length];
			spaces[] = ' ';
			if (input.length < 50)
				Stdout.formatln ("{}{} : {{{}}", spaces, where, input);
			else
				Stdout.formatln ("{}{} : {{{}}", spaces, where, input[0..50]);
			_trace ~= where;
		}

		private void report (T...) (char[] fmt, T args)
		{
			char[] spaces = (cast(char*) alloca (_trace.length)) [0 .. _trace.length];
			spaces[] = ' ';
			Stdout (spaces);
			Stdout.formatln (fmt, args);
		}

		private void trace (bool result)
		{
			//auto tmp = _trace[$-1];
			_trace = _trace[0..$-1];
				char[] spaces = (cast(char*) alloca (_trace.length)) [0 .. _trace.length];
				spaces[] = ' ';
				Stdout(spaces);
			if (!result)
				Stdout.formatln ("fail");
			else
				Stdout.formatln ("success");
		}
	}

	private char[] consume (uint amt)
	{
		char[] tmp = input[0 .. amt];
		input = input[amt .. $];
		return tmp;
	}

	/** */
	public char[] demangle (char[] input)
	{
		this.input = input;
		Buffer buf;
		if (MangledName (buf))
			return buf.slice.dup;
		else
			return input;
	}

	/** */
	public char[] demangle (char[] input, char[] output)
	{
		this.input = input;
		Buffer buf;
		if (MangledName (buf))
		{
			output[] = buf.slice;
			return output;
		}
		else
			return input;
	}

	private:

	bool MangledName (ref Buffer output)
	out (result)
	{
		debug(traceDemangler) trace (result);
	}
	body
	{
		debug(traceDemangler) trace ("MangledName");

		if (input[0..2] != "_D")
			return false;

		consume (2);

		if (! TypedQualifiedName (output))
			return false;

// 		if (input.length > 0 && input[0] == 'M')
// 		{
// 			consume (1);
// 
// 			Buffer typebuf;
// 
// 			if (! Type (typebuf))
// 				return false;
// 		}

		//Stdout.formatln ("MangledName={}", namebuf.slice);

		return true;
	}

	bool TypedQualifiedName (ref Buffer output)
	out (result)
	{
		debug(traceDemangler) trace (result);
	}
	body
	{
		debug(traceDemangler) trace ("TypedQualifiedName");

		Buffer car;
		if (! SymbolName (car))
			return false;
		output.append (car);

		Buffer type; // undocumented
		if (TypeFunction (type) && expandFunctionTypes)
		{
			output.append ("{");
			output.append (type);
			output.append ("}");
		}

		Buffer cdr;
		if (TypedQualifiedName (cdr))
		{
			if (!foldDefaults || !locatePattern (car.slice, cdr.slice) == 0)
			{
				output.append (".");
				output.append (cdr);
			}
		}

		return true;
	}

	bool QualifiedName (ref Buffer output, bool aliasHack = false)
	out (result)
	{
		debug(traceDemangler) trace (result);
	}
	body
	{
		debug(traceDemangler) trace (aliasHack ? "QualifiedNameAH" : "QualifiedName");

		Buffer car;
		if (! SymbolName (car, aliasHack))
			return false;
		output.append (car);

		Buffer cdr;
		if (TypedQualifiedName (cdr))
		{
			if (!foldDefaults || !locatePattern (car.slice, cdr.slice) == 0)
			{
				output.append (".");
				output.append (cdr);
			}
		}

		return true;
	}

	bool SymbolName (ref Buffer output, bool aliasHack = false)
	out (result)
	{
		debug(traceDemangler) trace (result);
	}
	body
	{
		debug(traceDemangler) trace (aliasHack ? "SymbolNameAH" : "SymbolName");

// 		if (TemplateInstanceName (output))
// 			return true;

		if (aliasHack)
		{
			if (LNameAliasHack (output))
				return true;
		}
		else
		{
			if (LName (output))
				return true;
		}

		return false;
	}

	bool LName (ref Buffer output)
	out (result)
	{
		debug(traceDemangler) trace (result);
	}
	body
	{
		debug(traceDemangler) trace ("LName");
		//try
		//{
			uint chars;
			if (! Number (chars))
				return false;

			char[] original = input;
			input = input[0 .. chars];
			uint len = input.length;
			Buffer buf;
			if (TemplateInstanceName (buf))
			{
				output.append (buf);
				input = original[len - input.length .. $];
				return true;
			}
			input = original;

			return Name (chars, output);
/+		}
		catch (Exception e)
		{
			debug(traceDemangler) report ("\033[1;31mException : {} @ {}:{}\033[0m", e.msg, e.file, e.line);
			return false;
		}+/
	}

	/* this hack is ugly and guaranteed to break, but the symbols
	   generated for template alias parameters are broken:
	   the compiler generates a symbol of the form S(number){(number)(name)}
	   with no space between the numbers; what we do is try to match
	   different combinations of division between the concatenated numbers */

	bool LNameAliasHack (ref Buffer output)
	out (result)
	{
		debug(traceDemangler) trace (result);
	}
	body
	{
		debug(traceDemangler) trace ("LNameAH");
		
// 		uint chars;
// 		if (! Number (chars))
// 			return false;

		uint chars;
		Buffer number;
		if (! NumberNoParse (number))
			return false;
		char[] str = number.slice;
		int i = 0;

		bool done = false;

		char[] original = input;
		char[] working = input;

		while (done == false)
		{
			if (i > 0)
			{
				input = working = original[0 .. to!(uint)(str[0..i])];
			}
			else
				input = working = original;

			chars = to!(uint)(str[i..$]);

			if (chars < input.length && chars > 0)
			{
				// cut the string from the right side to the number
				//char[] original = input;
				//input = input[0 .. chars];
				//uint len = input.length;
				debug(traceDemangler) report ("trying {}/{}", chars, input.length);
				Buffer buf;
				done = TemplateInstanceName (buf);
				//input = original[len - input.length .. $];

				if (done)
				{
					output.append (buf);
				}
				else
				{
					input = working;
					debug(traceDemangler) report ("trying {}/{}", chars, input.length);
					done = Name (chars, buf);
					if (done)
						output.append (buf);
				}

				if (done)
				{
					input = original[working.length - input.length .. $];
					return true;
				}
				else
					input = original;
			}

			i += 1;
			if (i == str.length)
				return false;
		}

		return true;
	}

	bool Number (ref uint value)
	out (result)
	{
		debug(traceDemangler) trace (result);
	}
	body
	{
		debug(traceDemangler) trace ("Number");

		if (input.length == 0)
			return false;
	
		value = 0;
		if (input[0] >= '0' && input[0] <= '9')
		{
			while (input.length > 0 && input[0] >= '0' && input[0] <= '9')
			{
				value = value * 10 + cast(uint) (input[0] - '0');
				consume (1);
			}
			return true;
		}
		else
			return false;
	}

	bool NumberNoParse (ref Buffer output)
	out (result)
	{
		debug(traceDemangler) trace (result);
	}
	body
	{
		debug(traceDemangler) trace ("NumberNP");
	
		if (input.length == 0)
			return false;

		if (input[0] >= '0' && input[0] <= '9')
		{
			while (input.length > 0 && input[0] >= '0' && input[0] <= '9')
			{
				output.append (input[0]);
				consume (1);
			}
			return true;
		}
		else
			return false;
	}

	bool Name (uint count, ref Buffer output)
	out (result)
	{
		debug(traceDemangler) trace (result);
	}
	body
	{
		debug(traceDemangler) trace ("Name");

		//if (input.length >= 3 && input[0 .. 3] == "__T")
		//	return false; // workaround

		if (count > input.length)
			return false;

		char[] name = consume (count);
		output.append (name);
		debug(traceDemangler) report (">>> name={}", name);

		return count > 0;
	}

	bool Type (ref Buffer output)
	out (result)
	{
		debug(traceDemangler) trace (result);
	}
	body
	{
		debug(traceDemangler) trace ("Type");

		Buffer subtype;

		switch (input[0])
		{
			case 'x':
				consume (1);
				output.append ("const ");
				return Type (output);

			case 'y':
				consume (1);
				output.append ("invariant ");
				return Type (output);

			case 'A':
				consume (1);
				if (Type (subtype))
				{
					output.append (subtype);
					output.append ("[]");
					return true;
				}
				return false;

			case 'G':
				consume (1);
				uint size;
				if (! Number (size))
					return false;
				if (Type (subtype))
				{
					output.append (subtype);
					output.append ("[" ~ to!(char[])(size) ~ "]");
					return true;
				}
				return false;

			case 'H':
				consume (1);
				Buffer keytype;
				if (! Type (keytype))
					return false;
				if (Type (subtype))
				{
					output.append (subtype);
					output.append ("[");
					output.append (keytype);
					output.append ("]");
					return true;
				}
				return false;

			case 'P':
				consume (1);
				if (Type (subtype))
				{
					output.append (subtype);
					output.append ("*");
					return true;
				}
				return false;

			case 'F': case 'U': case 'W': case 'V': case 'R': case 'D': case 'M':
				return TypeFunction (output);

			case 'I': case 'C': case 'S': case 'E': case 'T':
				return TypeNamed (output);

			case 'n':
				consume (1);
				output.append ("none");
				return true;

			case 'v':
				consume (1);
				output.append ("void");
				return true;

			case 'g':
				consume (1);
				output.append ("byte");
				return true;

			case 'h':
				consume (1);
				output.append ("ubyte");
				return true;

			case 's':
				consume (1);
				output.append ("short");
				return true;

			case 't':
				consume (1);
				output.append ("ushort");
				return true;

			case 'i':
				consume (1);
				output.append ("int");
				return true;

			case 'k':
				consume (1);
				output.append ("uint");
				return true;

			case 'l':
				consume (1);
				output.append ("long");
				return true;

			case 'm':
				consume (1);
				output.append ("ulong");
				return true;

			case 'f':
				consume (1);
				output.append ("float");
				return true;

			case 'd':
				consume (1);
				output.append ("double");
				return true;

			case 'e':
				consume (1);
				output.append ("real");
				return true;

			/* TODO: imaginary and complex types */

			case 'b':
				consume (1);
				output.append ("bool");
				return true;

			case 'a':
				consume (1);
				output.append ("char");
				return true;

			case 'u':
				consume (1);
				output.append ("wchar");
				return true;

			case 'w':
				consume (1);
				output.append ("dchar");
				return true;

			case 'B':
				consume (1);
				uint count;
				if (! Number (count))
					return false;
				output.append ('(');
				if (! Arguments (output))
					return false;
				output.append (')');
				return true;

			default:
				return false;
		}

		return true;
	}

	bool TypeFunction (ref Buffer output)
	out (result)
	{
		debug(traceDemangler) trace (result);
	}
	body
	{
		debug(traceDemangler) trace ("TypeFunction");

		bool isMethod = false;
		bool isDelegate = false;

		if (input.length == 0)
			return false;

		if (input[0] == 'M')
		{
			consume (1);
			isMethod = true;
		}

		if (input[0] == 'D')
		{
			consume (1);
			isDelegate = true;
			assert (! isMethod);
		}

		switch (input[0])
		{
			case 'F':
				consume (1);
				break;

			case 'U':
			 	consume (1);
			 	output.append ("extern(C) ");
			 	break;

			case 'W':
			 	consume (1);
			 	output.append ("extern(Windows) ");
			 	break;

			case 'V':
			 	consume (1);
			 	output.append ("extern(Pascal) ");
			 	break;

			case 'R':
			 	consume (1);
			 	output.append ("extern(C++) ");
			 	break;

			default:
				return false;
		}

		Buffer args;
		Arguments (args);

		switch (input[0])
		{
			case 'X': case 'Y': case 'Z':
				consume (1);
				break;
			default:
				return false;
		}

		Buffer ret;
		if (! Type (ret))
			return false;

		output.append (ret);
		//output.append (" ");
		
		if (isMethod)
			output.append (" method (");
		else if (isDelegate)
			output.append (" delegate (");
		else
			output.append (" function (");

		//output.append (" (");
		output.append (args);
		output.append (")");

		return true;
	}

	bool Arguments (ref Buffer output)
	out (result)
	{
		debug(traceDemangler) trace (result);
	}
	body
	{
		debug(traceDemangler) trace ("Arguments");

		Buffer car;
		if (! Argument (car))
			return false;
		output.append (car);

		Buffer cdr;
		if (Arguments (cdr))
		{
			output.append (", ");
			output.append (cdr);
		}

		return true;
	}

	bool Argument (ref Buffer output)
	out (result)
	{
		debug(traceDemangler) trace (result);
	}
	body
	{
		debug(traceDemangler) trace ("Argument");

		if (input.length == 0)
			return false;

		switch (input[0])
		{
			case 'K':
				consume (1);
				output.append ("inout ");
				break;

			case 'J':
				consume (1);
				output.append ("out ");
				break;

			case 'L':
				consume (1);
				output.append ("lazy ");
				break;
				
			default:
		}

		if (! Type (output))
			return false;
			
		return true;
	}

	bool TypeNamed (ref Buffer output)
	out (result)
	{
		debug(traceDemangler) trace (result);
	}
	body
	{
		debug(traceDemangler) trace ("TypeNamed");

		char[] kind;
		switch (input[0])
		{
			case 'I':
				consume (1);
				kind = "interface";
				break;
				
			case 'S':
				consume (1);
				kind = "struct";
				break;
			
			case 'C':
				consume (1);
				kind = "class";
				break;
			
			case 'E':
				consume (1);
				kind = "enum";
				break;
			
			case 'T':
				consume (1);
				kind = "typedef";
				break;
				
			default:
				return false;
		}

		//output.append (kind);
		//output.append ("=");

		if (! QualifiedName (output))
			return false;

		if (printTypeKind)
		{
			output.append ("<");
			output.append (kind);
			output.append (">");
		}
			
		return true;
	}

	bool TemplateInstanceName (ref Buffer output)
	out (result)
	{
		debug(traceDemangler) trace (result);
	}
	body
	{
		debug(traceDemangler) trace ("TemplateInstanceName");

		if (input.length < 4 || input[0..3] != "__T")
			return false;

		consume (3);

		if (! LName (output))
			return false;

		output.append ("!(");

		_templateDepth++;
		if (_templateDepth <= templateExpansionDepth)
			TemplateArgs (output);
		else
		{
			Buffer throwaway;
			TemplateArgs (throwaway);
			output.append ("...");
		}
		_templateDepth--;

		if (input.length > 0 && input[0] != 'Z')
			return false;

		output.append (")");
		
		consume (1);
		return true;
	}

	bool TemplateArgs (ref Buffer output)
	out (result)
	{
		debug(traceDemangler) trace (result);
	}
	body
	{
		debug(traceDemangler) trace ("TemplateArgs");

		Buffer car;
		if (! TemplateArg (car))
			return false;
		output.append (car);

		Buffer cdr;
		if (TemplateArgs (cdr))
		{
			output.append (", ");
			output.append (cdr);
		}

		return true;
	}

	bool TemplateArg (ref Buffer output)
	out (result)
	{
		debug(traceDemangler) trace (result);
	}
	body
	{
		debug(traceDemangler) trace ("TemplateArg");

		if (input.length == 0)
			return false;

		switch (input[0])
		{
			case 'T':
				consume (1);
				if (! Type (output))
					return false;
				return true;

			case 'V':
				consume (1);
				Buffer throwaway;
				if (! Type (throwaway))
					return false;
				if (! Value (output))
					return false;
				return true;

			case 'S':
				consume (1);
				if (! QualifiedName (output, true))
					return false;
				return true;

			default:
				return false;
		}

		return false;
	}

	bool Value (ref Buffer output)
	out (result)
	{
		debug(traceDemangler) trace (result);
	}
	body
	{
		debug(traceDemangler) trace ("Value");

		if (input.length == 0)
			return false;

		switch (input[0])
		{
			case 'n':
				consume (1);
				return true;

			case 'N':
				consume (1);
				output.append ('-');
				if (! NumberNoParse (output))
					return false;
				return true;

			case 'e':
				consume (1);
				if (! HexFloat (output))
					return false;
				return true;

			case 'c': //TODO

			case 'A':
				consume (1);
				uint count;
				if (! Number (count))
					return false;
				output.append ("[");
				for (uint i = 0; i < count-1; i++)
				{
					if (! Value (output))
						return false;
					output.append (", ");
				}
				if (! Value (output))
					return false;
				output.append ("]");
				return true;

			default:
				if (! NumberNoParse (output))
					return false;
				return true;
		}

		return false;
	}

	bool HexFloat (ref Buffer output)
	out (result)
	{
		debug(traceDemangler) trace (result);
	}
	body
	{
		debug(traceDemangler) trace ("HexFloat");

		if (input[0 .. 3] == "NAN")
		{
			consume (3);
			output.append ("nan");
			return true;
		}
		else if (input[0 .. 3] == "INF")
		{
			consume (3);
			output.append ("+inf");
			return true;
		}
		else if (input[0 .. 3] == "NINF")
		{
			consume (3);
			output.append ("-inf");
			return true;
		}

		bool negative = false;
		if (input[0] == 'N')
		{
			consume (1);
			negative = true;
		}

		ulong num;
		if (! HexNumber (num))
			return false;

		if (input[0] != 'P')
			return false;

		bool negative_exponent = false;
		if (input[0] == 'N')
		{
			consume (1);
			negative_exponent = true;
		}

		uint exponent;
		if (! Number (exponent))
			return false;

		return true;
	}

	static bool isHexDigit (char c)
	{
		return (c > '0' && c <'9') || (c > 'a' && c < 'f') || (c > 'A' && c < 'F');
	}

	bool HexNumber (ref ulong value)
	out (result)
	{
		debug(traceDemangler) trace (result);
	}
	body
	{
		debug(traceDemangler) trace ("HexFloat");

		if (isHexDigit (input[0]))
		{
			while (isHexDigit (input[0]))
			{
				//output.append (input[0]);
				consume (1);
			}
			return true;
		}
		else
			return false;
	}
}

private struct Buffer
{
	char[4096] data;
	size_t     length;

	void append (char[] s)
	{
		data[this.length .. this.length + s.length] = s;
		this.length += s.length;
	}

	void append (char c)
	{
		data[this.length .. this.length + 1] = c;
		this.length += 1;
	}

	void append (Buffer b)
	{
		append (b.slice);
	}

	char[] slice ()
	{
		return data[0 .. this.length];
	}
}
